<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Matt Alcock]]></title>
  <link href="http://mattalcock.github.com/atom.xml" rel="self"/>
  <link href="http://mattalcock.github.com/"/>
  <updated>2012-05-10T00:56:29+01:00</updated>
  <id>http://mattalcock.github.com/</id>
  <author>
    <name><![CDATA[Matt Alcock]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Sorting Algorithms]]></title>
    <link href="http://mattalcock.github.com/blog/2012/04/22/python-sorting-algorithms/"/>
    <updated>2012-04-22T13:41:00+01:00</updated>
    <id>http://mattalcock.github.com/blog/2012/04/22/python-sorting-algorithms</id>
    <content type="html"><![CDATA[<p>So how fast is sorting in Python? What algorithms are there out there and how do they perform over different array sizes and situations?
This blog post helps answer these questions and gives some insight into the powerful performance of the inbuilt python sort function. I&#8217;m sure many people have run &#8216;sort(list)&#8217; and then wondered what algorithm has that just used. If my list get really big is that going to be dog slow or super fast?</p>

<p>Sorting is a key algorithms, keeping data structures sorted helps search, lookup and a multitude of other operations. Many algorithms include sorting as component of there execution. Getting the sorting right can offer lower the order of magnitude of processing and make that slow, poor performing process super fast!</p>

<p>So what sorting algorithms are there out there.</p>

<p>Three often discussed algorithms are</p>

<ul>
<li> Merge Sort</li>
<li> Quick Sort</li>
<li> Insertion Sort</li>
</ul>


<p>We&#8217;ll look at each of these and then compare there speed using a randomly generated list of ints. (Testing speed with alphanumeric and strings is also worthy of investigation but is beyond this post)</p>

<h3>Merge Sort</h3>

<p>Merge sort is a comparative divide and conquer algorithm. The algorithm recursively divides up list until the length is one and then recombines using a merge function that maintains the sorted order as it recombines the lists. Merge sort is often described to be an O(nlogn) algorithm.</p>

<figure class='code'><figcaption><span>Merge Sort  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#Merge</span>
</span><span class='line'><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span><span class='line'>    <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span><span class='line'>            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">else</span><span class="p">:</span>
</span><span class='line'>            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">+=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>
</span><span class='line'><span class="c">#Merge Sort</span>
</span><span class='line'><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
</span><span class='line'>    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</span><span class='line'>    <span class="n">cut</span><span class="o">=</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">length</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">l</span>
</span><span class='line'>    <span class="c">#left = merge_sort(l[:cut])</span>
</span><span class='line'>    <span class="c">#right = merge_sort(l[cut:])</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">merge_sort</span><span class="p">(</span><span class="n">l</span><span class="p">[:</span><span class="n">cut</span><span class="p">]),</span>  <span class="n">merge_sort</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">cut</span><span class="p">:]))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Quick Sort</h3>

<p>Quick sort like merge sort is another divide and conquer algorithm that is recursive in nature. A pivot value is chosen (below i use the half way point other approaches use the last or first element) and then the lists are broken into 3 parts. Lists which contain values larger and lower than the pivot and the pivot itself. These segmented lists are then themselves sorted. Once the list size is 1 these lists are then in the correct place to be recombined using list concatenation. This algorithm is also descriibed to be an O(nlogn) algorthim but not it&#8217;s worst case operation can be O(n<sup>2)</sup> although this worst case is rare.</p>

<figure class='code'><figcaption><span>Quick Sort  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#Quick Sort</span>
</span><span class='line'><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
</span><span class='line'>    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">l</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">pivot</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</span><span class='line'>        <span class="n">less</span><span class="p">,</span> <span class="n">more</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">:</span>
</span><span class='line'>                <span class="n">less</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>            <span class="k">else</span><span class="p">:</span>
</span><span class='line'>                <span class="n">more</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">less</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">more</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Insertion Sort</h3>

<p>Insertion sort is a very simple comparative sorting algorithm which is not recursive. In this algorithm the sorted array is built one entry at a time. The power of this algorithm is that only requires constant space (O(1) space) as it is an &#8216;in place&#8217; algorithm using only a few variables and the list itself to move items around. The problem with insertion sort is that with large lists its terribly inefficient and is a O(n<sup>2)</sup> algorithm</p>

<figure class='code'><figcaption><span>Insertion Sort  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#Insertion Sort</span>
</span><span class='line'><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">save</span><span class="o">=</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">j</span><span class="o">=</span><span class="n">i</span>
</span><span class='line'>        <span class="k">while</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">save</span><span class="p">:</span>
</span><span class='line'>            <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'>            <span class="n">j</span><span class="o">-=</span><span class="mi">1</span>
</span><span class='line'>        <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">save</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">l</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Speed Test</h3>

<p>So in order to compare these algorithms to each other and python inbuilt sort. I decided to code up a speed test function and some code to generate random unsorted integer lists. The code for this can be found in my &#8216;hacks&#8217; project and under the &#8216;algos&#8217; folder.</p>

<p>The first test was just to run these four algorithms. The three above and pythons inbuilt sort to compare how these far on small lists of ints. Straight away you can see that the insertion sort is O(n<sup>2)</sup> and as n gets larger the performance drops of drastically.</p>

<p><img src="images/algos/sort-compare-small.png"></p>

<p>You can also see how well the inbuilt algorithm fairs as well as the merge and quick sort algorithms. I wanted to see how well insertion sort did on very small list sizes and the below shows the same tests on lists lower than 50 items.</p>

<p><img src="images/algos/sort-compare-micro.png"></p>

<p>As you can see although insertion sort is terrible at large list sizes the fact that its &#8216;in place&#8217; and not recursive means its actually quite good at small lists consistently beating both merge and quick sort for list under 16 elements.</p>

<h4>So why is the inbuilt algorithm so good?</h4>

<p>The inbuilt algorithm uses an adaptive merge sort algorithm. I decided to create adaptive versions of the quick sort algorithms. These algorithms take a sort function and use that on small lists. The below code shows a default using insertion sort when the list is less then 7 elements in length.</p>

<figure class='code'><figcaption><span>Adaptive Quick Sort  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#Adaptive Quick Sort</span>
</span><span class='line'><span class="k">def</span> <span class="nf">adapt_quick_sort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">sortf</span><span class="o">=</span><span class="n">insert_sort</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
</span><span class='line'>    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;=</span><span class="n">size</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">insert_sort</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">pivot</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</span><span class='line'>        <span class="n">less</span><span class="p">,</span> <span class="n">more</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">:</span>
</span><span class='line'>                <span class="n">less</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>            <span class="k">else</span><span class="p">:</span>
</span><span class='line'>                <span class="n">more</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">less</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">more</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This adaptive sort takes maybe milliseconds of the merge sort algorithm above. The inbuilt sort is still an order of magnitude faster. In my next post we&#8217;ll dig into why and look at how you can embed C code python to get extremely high performance sorting&#8230;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Subway Paths]]></title>
    <link href="http://mattalcock.github.com/blog/2012/01/31/subway-paths/"/>
    <updated>2012-01-31T23:53:00+00:00</updated>
    <id>http://mattalcock.github.com/blog/2012/01/31/subway-paths</id>
    <content type="html"><![CDATA[<p>Urban planner Neil Freeman maps the world&#8217;s subway systems to scale in a minimal style resembling the scribbles or renderings of weird sea creatures by a two-year-old. I wish there were nodes to show stops, too, but the contrasts between the compact TRTA in Tokyo and RATP in Paris, and the spread out Seoul Metro and Transport for London is an interesting look.</p>

<p><img src="images/subway.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Carbon Calculator]]></title>
    <link href="http://mattalcock.github.com/blog/2012/01/31/carbon-calculator/"/>
    <updated>2012-01-31T23:52:00+00:00</updated>
    <id>http://mattalcock.github.com/blog/2012/01/31/carbon-calculator</id>
    <content type="html"><![CDATA[<p>The Carbon Calculator developed by Vizzuality is an interactive mapping tool that reveals the potential contribution of any selected area in the world to climate change mitigation. The online tool calculates rough estimates of user-selected areas on a wide set of parameters, including: the carbon stored in above and below ground live biomass and soil, the percentage overlap with existing protected areas, the status of forests, the restoration potential inside selected areas, the maximum carbon sequestration potential.</p>

<p>As an original approach, the mapping tool allows users to draw a line around their area of interest, or select any protected area, from which the detailed information and statistics are shown.</p>

<p>The tool uses data delivered by CBD Secretariat (Convention on Biological Diversity), LifeWeb (CBD Programme of Work on Protected Areas) and UNEP-WCMC (UNEP World Conservation Monitoring Centre).</p>

<p>See a comparison of London with the New Forest below. I love the styling of the comparison statistics and the way you can great polygon areas and comparisons.</p>

<p>Screen grab of polygon comparison&#8230;</p>

<p><img src="images/carboncalc_snippet.png"></p>

<p><img src="images/carboncalculator.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Twitterati]]></title>
    <link href="http://mattalcock.github.com/blog/2012/01/25/twitterati/"/>
    <updated>2012-01-25T23:49:00+00:00</updated>
    <id>http://mattalcock.github.com/blog/2012/01/25/twitterati</id>
    <content type="html"><![CDATA[<p>Using large unstructured and noisy (aka dirty) data source to drive insight and intelligence is not new. It&#8217;s been around for centuries, the Collective Intelligence of the many have offered insights and direction for animals, civilisations, leaders and organisations for hundreds of years. What is more recent is the tools to systematically analyse these massive amounts of data, they are constantly improving and have matured dramatically over the recent years. Ok so whats new?</p>

<p>Data has never really been easy to access and has often been held behind closed doors. With easy access to large data sets the barrier to entry is lower and it&#8217;s far easier to generate collective intelligence. There have been lots of public data sets available over the past 10 or 20 years but its normally very focused to a domain or subject matter. Wikipedia revolutionised the world with an open encyclopaedia of information but pulling out insight from the data isn&#8217;t simple when the data is highly structured around a relatively static subject and often descriptive in nature rather than opinionated. So where can we get massive amounts of data, in a easily accessible manner, which contains insights and options about any subject?</p>

<p>Enter twitter and more especially an free and easy to use api (application programming interface) and masses amounts of data. (Twitter API) A tweet is an easy data item to model and can it contain massive amounts of insight if processed, aggregated and visualised appropriately. The scale, simplicity of a simple tweet is extremely powerful. This has created an extreme explosion of companies programmers and tools that analyse twitter data. The start of the Twitterati&#8230;</p>

<p><img src="images/tweet.jpeg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Written Images]]></title>
    <link href="http://mattalcock.github.com/blog/2011/05/10/written-images/"/>
    <updated>2011-05-10T00:12:00+01:00</updated>
    <id>http://mattalcock.github.com/blog/2011/05/10/written-images</id>
    <content type="html"><![CDATA[<p>I love creative projects that use technology and I enjoy funding inspiring people through kickstarter. So when I found out about the ‘Written Images’ project I had to get involved and back their fund raising. Their project is to create and print a batch of totally individual art books.</p>

<p>The team use input from artists that span the globe to generate these unique books. Artists submit Processing (an artistic coding language) code to a central system that in tern source different publicly available data to derive or seed the individual art forms. These art forms are collected and a high quality printed book is generated. Some of there artwork and a brief video of how the process works are below&#8230;</p>

<iframe frameborder="0" height="360px" src="http://www.kickstarter.com/projects/deffekt/written-images/widget/video.html" width="560px"></iframe>


<p><img src="images/written-images/image-48956-full.jpeg">
<img src="images/written-images/image-48957-full.jpeg">
<img src="images/written-images/image-48958-full.jpeg">
<img src="images/written-images/image-48959-full.jpeg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Continuum]]></title>
    <link href="http://mattalcock.github.com/blog/2011/05/09/continuum/"/>
    <updated>2011-05-09T00:23:00+01:00</updated>
    <id>http://mattalcock.github.com/blog/2011/05/09/continuum</id>
    <content type="html"><![CDATA[<p>I love the marriage of design, fashion and technology in this project. This is another one of the projects I’m funding through kickstarter. Mary Huang a graduate of UCLA Design and Media Arts has been working with Jenna Fizel to create a web based drawing application that lets you model you own little black dress. Although I’m not a frequent wearer of ladies clothing I still find the project extremely interesting. The style of the dress is driven by the Processing algorithm however the shape, layout and dimensions are completely customisable. Here is what Mary had to say about the project……</p>

<p>Continuum is a user-generated fashion collection. I call it computational couture. It is the application of interactive technologies for bespoke design.</p>

<p>In short, an app lets you draw a dress, turns it into a 3D model, and exports a cutting pattern to make the real dress, sized to your measurements. A laser cutter or plotter cuts the pattern out of fabric, which is then sewn into the dress. All the designs are unified around the theme of the little black dress, and the triangulation used in the software. This allows basically everyone to create their own innovative dress design.</p>

<p>Some screen grabs of the application. Try it out here -></p>

<p><img src="images/continuum/tumblr_lhtiftYCJP1qgazx9.jpeg">
<img src="images/continuum/tumblr_lhtigjetoc1qgazx9.jpeg"></p>
]]></content>
  </entry>
  
</feed>
